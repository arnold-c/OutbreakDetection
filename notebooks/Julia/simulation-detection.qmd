---
title: "Outbreak Threshold Detection"
author: "Callum Arnold"
date: today
title-block-banner: true
format:
  html:
    theme: flatly
    toc: true
    toc-depth: 4
    code-copy: true
    code-fold: true
    code-overflow: wrap
    code-tools: true
    code-link: true
    anchor-sections: true
    fig-width: 10
    fig-height: 8
execute:
  cache: true
jupyter: julia-1.9
---

```{julia}
using DrWatson
quickactivate(@__DIR__, "OutbreakDetection")
```

```{julia}
using JumpProcesses, StochasticDiffEq, DifferentialEquations, LinearAlgebra
using Catalyst, Random, Statistics, DataFrames, DataFramesMeta
using CairoMakie, AlgebraOfGraphics
using BenchmarkTools, ProgressMeter

CairoMakie.activate!()
set_aog_theme!()
```

```{julia}
tmax = 10.0
δt = 0.1/365
tspan = (0.0, tmax)
tlength = length(tspan[1]:δt:tspan[2])
Random.seed!(1234);

u₀ = [999.0, 10.0, 0.0, 0.0]

μ = 1
β = 1000
σ = 365/8
γ = 365/5
ε = 100
p = (β, σ, γ, μ, ε)
```

```{julia}
x = 0:0.1:10
fig = lines(x, 0.5 .* (sin.(2pi .* x) .+ 1))
vlines!(collect(0:1:10); color = (:red, 0.5), linestyle = :dash)
fig
```

```{julia}
# 0.5 .* (sin.(2π .* x) .+ 1)
expose_rate(u, p, t) = p[1] * 0.5 * (sin(2π * t) + 1) * u[1] * u[2]/ (u[1] + u[2] + u[3] + u[4])  # β * ϕ * S * I / N
function expose_affect!(integrator)
    integrator.u[1] -= 1         # S -> S - 1
    integrator.u[2] += 1         # E -> E + 1
    nothing
end

# We require that rate1(u,p,s) <= urate(u,p,s)
# for t <= s <= t + rateinterval(u,p,t)
urate(u, p, t) = p[1] * u[1] * u[2]/ (u[1] + u[2] + u[3] + u[4]) 
# Optionally, we can give a lower bound over the same interval.
# This may boost computational performance.
lrate(u, p, t) = 0 

# rateinterval needs to be between lrate <= ri <= urate
rateinterval(u, p, t) = 1 / (2 * urate(u, p, t))

# now we construct the bounded VariableRateJump
expose_jump = VariableRateJump(expose_rate, expose_affect!; lrate, urate, rateinterval)

# import_expose_rate(u, p, t) = p[5]
# function import_expose_affect!(integrator)
#     integrator.u[3] += 1         # I -> I + 1
#     nothing
# end
# import_expose_jump = ConstantRateJump(import_expose_rate, import_expose_affect!)

infec_rate(u, p, t) = p[2] * u[2]   # σ * E
function infec_affect!(integrator)
    integrator.u[2] -= 1         # E -> E - 1
    integrator.u[3] += 1         # I -> I + 1
    nothing
end
infec_jump = ConstantRateJump(infec_rate, infec_affect!)

recov_rate(u, p, t) = p[3] * u[3]   # γ * I
function recov_affect!(integrator)
    integrator.u[3] -= 1         # I -> I - 1
    integrator.u[4] += 1         # R -> R + 1
    nothing
end
recov_jump = ConstantRateJump(recov_rate, recov_affect!)

birth_rate(u, p, t) = p[4] * (u[1] + u[2] + u[3] + u[4]) # μ * N
function birth_affect!(integrator)
    integrator.u[1] += 1         # S -> S + 1
    nothing
end
birth_jump = ConstantRateJump(birth_rate, birth_affect!)

S_death_rate(u, p, t) = p[4] * u[1] # μ * S
function S_death_affect!(integrator)
    integrator.u[1] -= 1        # S -> S - 1
end
S_death_jump = ConstantRateJump(S_death_rate, S_death_affect!)

E_death_rate(u, p, t) = p[4] * u[2] # μ * E
function E_death_affect!(integrator)
    integrator.u[2] -= 1        # E -> E -1
end
E_death_jump = ConstantRateJump(E_death_rate, E_death_affect!)

I_death_rate(u, p, t) = p[4] * u[3] # μ * I
function I_death_affect!(integrator)
    integrator.u[3] -= 1        # I -> I - 1
end
I_death_jump = ConstantRateJump(I_death_rate, I_death_affect!)

R_death_rate(u, p, t) = p[4] * u[4] # μ * R
function R_death_affect!(integrator)
    integrator.u[4] -= 1        # R -> R - 1 
end
R_death_jump = ConstantRateJump(R_death_rate, R_death_affect!)

gillespie_jumps = [
    expose_jump, infec_jump, recov_jump, birth_jump, S_death_jump, E_death_jump,
    I_death_jump, R_death_jump
]
```

```{julia}
# Constant jumps are ordered ahead of VariableJumps, but otherwise retain the ordering
dep_graph = [
    [1, 8],    # infec depends on states changed by itself and exposure jump
    [2],    # recov depends on states changed by itself
    [3],    # birth depends on states changed by itself
    [4, 8],    # S_death depends on states changed by itself and exposure jump
    [5, 8],    # E_death depends on states changed by itself and exposure jump
    [6],    # I_death depends on states changed by itself
    [7],    # R_death depends on states changed by itself and exposure jump
    [1, 3, 4, 5, 8]    # Exposure jump depends on states changed by itself, birth, S_death, E_death, and infection jumps
    ]

prob = DiscreteProblem(u₀, tspan, p)
jump_prob = JumpProblem(prob, Coevolve(), gillespie_jumps...; dep_graph)
sol = solve(jump_prob, SSAStepper())
sol_array = zeros(6, length(sol))
sol_array[1:4, :] = Array(sol)[1:4, :]
sol_array[5, :] = sum(sol_array[1:4, :], dims = 1)
sol_array[6, :] = sol.t
```

```{julia}
sol_df = DataFrame(Tables.table(sol_array'))

rename!(sol_df, :Column1 => :S, :Column2 => :E, :Column3 => :I, :Column4 => :R, :Column5 => :N, :Column6 => :time)

stacked_df = stack(sol_df, [:S, :E, :I, :R, :N])
```

```{julia}
colors = ["dodgerblue4", "firebrick3", "chocolate2", "green", "purple"]
sir_plot = data(stacked_df) *
    mapping(
        :time => "Time (Years)", :value => "Number",
        color = :variable => sorter("S", "E", "I", "R", "N") => "State"
    ) *
    visual(Lines, linewidth = 4)

draw(
    sir_plot;
    palettes = (; color = colors),
    axis = (; limits = ((0.0, 2.0), nothing))
    )
```

```{julia}
function run_sir_sim(; u₀, tspan, p)
    prob = DiscreteProblem(u₀, tspan, p)
    jump_prob = JumpProblem(
        prob, Coevolve(), gillespie_jumps..., save_positions = (false, false);
        dep_graph
        )
    jump_sol = solve(jump_prob, SSAStepper(), saveat = δt)
    return jump_sol;
end
```

```{julia}
function create_sim_array!(; out_jump)
    sir_array[1:4, :] = Array(out_jump)
    sir_array[5, :] = sum(sir_array[1:4, :], dims = 1) 
    sir_array[6, :] .= out_jump.t

    return nothing
end
```

```{julia}
sir_sim_plot = Figure()
ax = Axis(sir_sim_plot[1, 1],
    xlabel = "Time",
    ylabel = "Number"
)

nsims = 100

sir_array = zeros(6, tlength + 1)

all_sims_array = zeros(Float64, 6, tlength + 1, nsims)
sim_means = zeros(Float64, 5, tlength + 1)

@showprogress for i in 1:nsims
    out_jump = run_sir_sim(u₀ = u₀, tspan = tspan, p = p)
    create_sim_array!(out_jump = out_jump)

    all_sims_array[:, :, i] = sir_array


    lines!(ax, sir_array[6, :], sir_array[1, :], linewidth = 4, color = ("dodgerblue4", 0.02))
    lines!(ax, sir_array[6, :], sir_array[2, :], linewidth = 4, color = ("firebrick3", 0.02))
    lines!(ax, sir_array[6, :], sir_array[3, :], linewidth = 4, color = ("chocolate2", 0.02)) 
    lines!(ax, sir_array[6, :], sir_array[4, :], linewidth = 4, color = ("green", 0.02)) 
    lines!(ax, sir_array[6, :], sir_array[5, :], linewidth = 4, color = ("purple", 0.02)) 
    
end

@showprogress for outcome in 1:5
    sim_means[outcome, :] = median(all_sims_array[outcome, :, :], dims = 2)
end

lines!(ax, sir_array[6, :], sim_means[1, :], linewidth = 3, color = "dodgerblue4", label = "S(t)")
lines!(ax, sir_array[6, :], sim_means[2, :], linewidth = 3, color = "firebrick3", label = "E(t)")
lines!(ax, sir_array[6, :], sim_means[3, :], linewidth = 3, color = "chocolate2", label = "I(t)")
lines!(ax, sir_array[6, :], sim_means[4, :], linewidth = 3, color = "green", label = "R(t)")
lines!(ax, sir_array[6, :], sim_means[5, :], linewidth = 3, color = "purple", label = "N(t)")

Legend(sir_sim_plot[1, 2], ax, "State")

sir_sim_plot
```
